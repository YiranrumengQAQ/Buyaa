<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Då…‰çº¿è¿½è¸ª - é»‘å±‹ç¯å…‰åœºæ™¯</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 15, 20, 0.92);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .control-group {
            margin-bottom: 18px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .control-group:last-child {
            border-bottom: none;
        }

        .control-label {
            display: block;
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            color: #667eea;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }

        .preset-colors {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        .preset-color {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .preset-color:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 15, 20, 0.92);
            backdrop-filter: blur(12px);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.85rem;
            color: #aaa;
        }

        @media (max-width: 768px) {
            .controls-panel {
                top: 10px;
                right: 10px;
                min-width: 240px;
                padding: 15px;
                max-height: 85vh;
            }

            .info-panel {
                bottom: 10px;
                left: 10px;
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas3d"></canvas>

        <div class="controls-panel">
            <div class="panel-title">ğŸ›ï¸ å…‰ç…§æ§åˆ¶å°</div>

            <div class="control-group">
                <label class="control-label">
                    <span>ç¯å…‰é¢œè‰²</span>
                </label>
                <input type="color" id="lightColor" value="#ffdd66">
                <div class="preset-colors">
                    <div class="preset-color" style="background:#ffdd66" data-color="#ffdd66"></div>
                    <div class="preset-color" style="background:#ff6666" data-color="#ff6666"></div>
                    <div class="preset-color" style="background:#66ff66" data-color="#66ff66"></div>
                    <div class="preset-color" style="background:#6666ff" data-color="#6666ff"></div>
                    <div class="preset-color" style="background:#ff66ff" data-color="#ff66ff"></div>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">
                    <span>ç¯å…‰å¼ºåº¦</span>
                    <span class="control-value" id="intensityValue">1.5</span>
                </label>
                <input type="range" id="lightIntensity" min="0" max="3" step="0.1" value="1.5">
            </div>

            <div class="control-group">
                <label class="control-label">
                    <span>å…‰é”¥è§’åº¦</span>
                    <span class="control-value" id="coneValue">45Â°</span>
                </label>
                <input type="range" id="coneAngle" min="15" max="90" step="1" value="45">
            </div>

            <div class="control-group">
                <label class="control-label">
                    <span>åœ°æ¿åå°„ç‡</span>
                    <span class="control-value" id="reflectionValue">0.70</span>
                </label>
                <input type="range" id="floorReflection" min="0" max="1" step="0.01" value="0.70">
            </div>

            <div class="control-group">
                <label class="control-label">
                    <span>å…‰é”¥å¯†åº¦</span>
                    <span class="control-value" id="volumetricValue">0.40</span>
                </label>
                <input type="range" id="volumetricDensity" min="0" max="1" step="0.01" value="0.40">
            </div>

            <div class="control-group">
                <label class="control-label">
                    <span>ç¯å¢ƒå…‰</span>
                    <span class="control-value" id="ambientValue">0.05</span>
                </label>
                <input type="range" id="ambientLight" min="0" max="0.3" step="0.01" value="0.05">
            </div>

            <div class="control-group">
                <label class="control-label">
                    <span>ç›¸æœºè·ç¦»</span>
                    <span class="control-value" id="distanceValue">20</span>
                </label>
                <input type="range" id="cameraDistance" min="10" max="40" step="1" value="20">
            </div>
        </div>

        <div class="info-panel">
            ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬è§†è§’ | FPS: <span id="fps">60</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas3d');
        const ctx = canvas.getContext('2d');

        // å“åº”å¼è®¾ç½®
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 3Då‘é‡ç±»
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            add(v) {
                return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
            }

            sub(v) {
                return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
            }

            mul(s) {
                return new Vec3(this.x * s, this.y * s, this.z * s);
            }

            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }

            length() {
                return Math.sqrt(this.dot(this));
            }

            normalize() {
                const len = this.length();
                return len > 0 ? this.mul(1 / len) : new Vec3();
            }

            reflect(n) {
                return this.sub(n.mul(2 * this.dot(n)));
            }
        }

        // åœºæ™¯å‚æ•°
        let params = {
            lightColor: [255, 221, 102],
            lightIntensity: 1.5,
            coneAngle: 45,
            floorReflection: 0.70,
            volumetricDensity: 0.40,
            ambientLight: 0.05,
            cameraDistance: 20,
            cameraAngleX: 0.3,
            cameraAngleY: 0
        };

        // å…‰æºä½ç½®ï¼ˆç›¸å¯¹äºæˆ¿é—´ä¸­å¿ƒï¼‰
        const lightPos = new Vec3(0, 3, 0);

        // æ§åˆ¶é¢æ¿äº‹ä»¶
        document.getElementById('lightColor').addEventListener('input', (e) => {
            const hex = e.target.value.substring(1);
            params.lightColor = [
                parseInt(hex.substr(0, 2), 16),
                parseInt(hex.substr(2, 2), 16),
                parseInt(hex.substr(4, 2), 16)
            ];
        });

        document.querySelectorAll('.preset-color').forEach(el => {
            el.addEventListener('click', () => {
                const color = el.dataset.color;
                document.getElementById('lightColor').value = color;
                const hex = color.substring(1);
                params.lightColor = [
                    parseInt(hex.substr(0, 2), 16),
                    parseInt(hex.substr(2, 2), 16),
                    parseInt(hex.substr(4, 2), 16)
                ];
            });
        });

        document.getElementById('lightIntensity').addEventListener('input', (e) => {
            params.lightIntensity = parseFloat(e.target.value);
            document.getElementById('intensityValue').textContent = e.target.value;
        });

        document.getElementById('coneAngle').addEventListener('input', (e) => {
            params.coneAngle = parseFloat(e.target.value);
            document.getElementById('coneValue').textContent = e.target.value + 'Â°';
        });

        document.getElementById('floorReflection').addEventListener('input', (e) => {
            params.floorReflection = parseFloat(e.target.value);
            document.getElementById('reflectionValue').textContent = e.target.value;
        });

        document.getElementById('volumetricDensity').addEventListener('input', (e) => {
            params.volumetricDensity = parseFloat(e.target.value);
            document.getElementById('volumetricValue').textContent = e.target.value;
        });

        document.getElementById('ambientLight').addEventListener('input', (e) => {
            params.ambientLight = parseFloat(e.target.value);
            document.getElementById('ambientValue').textContent = e.target.value;
        });

        document.getElementById('cameraDistance').addEventListener('input', (e) => {
            params.cameraDistance = parseFloat(e.target.value);
            document.getElementById('distanceValue').textContent = e.target.value;
        });

        // é¼ æ ‡æ‹–æ‹½æ§åˆ¶
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                params.cameraAngleY += deltaX * 0.005;
                params.cameraAngleX += deltaY * 0.005;
                params.cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, params.cameraAngleX));
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // è§¦æ‘¸æ”¯æŒ
        canvas.addEventListener('touchstart', (e) => {
            isDragging = true;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging) {
                const deltaX = e.touches[0].clientX - lastMouseX;
                const deltaY = e.touches[0].clientY - lastMouseY;
                params.cameraAngleY += deltaX * 0.005;
                params.cameraAngleX += deltaY * 0.005;
                params.cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, params.cameraAngleX));
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            }
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // ç›¸æœºå˜æ¢
        function getCameraPosition() {
            const dist = params.cameraDistance;
            const x = dist * Math.cos(params.cameraAngleX) * Math.sin(params.cameraAngleY);
            const y = dist * Math.sin(params.cameraAngleX);
            const z = dist * Math.cos(params.cameraAngleX) * Math.cos(params.cameraAngleY);
            return new Vec3(x, y, z);
        }

        // å°„çº¿-å¹³é¢ç›¸äº¤
        function rayPlaneIntersect(origin, dir, planeY) {
            if (Math.abs(dir.y) < 0.001) return null;
            const t = (planeY - origin.y) / dir.y;
            if (t < 0) return null;
            return origin.add(dir.mul(t));
        }

        // å°„çº¿-çƒä½“ç›¸äº¤
        function raySphereIntersect(origin, dir, center, radius) {
            const oc = origin.sub(center);
            const a = dir.dot(dir);
            const b = 2 * oc.dot(dir);
            const c = oc.dot(oc) - radius * radius;
            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) return null;

            const t = (-b - Math.sqrt(discriminant)) / (2 * a);
            if (t > 0.001) {
                const point = origin.add(dir.mul(t));
                const normal = point.sub(center).normalize();
                return { t, point, normal };
            }
            return null;
        }

        // å…‰é”¥æ£€æµ‹
        function isInLightCone(point) {
            const toPoint = point.sub(lightPos).normalize();
            const lightDir = new Vec3(0, -1, 0);
            const angle = Math.acos(toPoint.dot(lightDir));
            const maxAngle = (params.coneAngle * Math.PI) / 180;
            return angle < maxAngle;
        }

        // å…‰ç…§è®¡ç®—
        function computeLighting(point, normal, viewDir) {
            let color = [0, 0, 0];

            // ç¯å¢ƒå…‰
            for (let i = 0; i < 3; i++) {
                color[i] = params.lightColor[i] * params.ambientLight;
            }

            // æ£€æŸ¥æ˜¯å¦åœ¨å…‰é”¥å†…
            if (!isInLightCone(point)) {
                return color;
            }

            // è®¡ç®—å…‰ç…§
            const lightDir = lightPos.sub(point).normalize();
            const distance = lightPos.sub(point).length();
            const attenuation = 1 / (1 + 0.05 * distance + 0.01 * distance * distance);

            // æ¼«åå°„
            const diffuse = Math.max(0, normal.dot(lightDir));

            // é•œé¢åå°„
            const reflectDir = lightDir.reflect(normal);
            const specular = Math.pow(Math.max(0, viewDir.dot(reflectDir)), 64);

            for (let i = 0; i < 3; i++) {
                color[i] += params.lightColor[i] * params.lightIntensity * attenuation * 
                           (diffuse * 0.7 + specular * 0.3);
            }

            return color;
        }

        // å…‰çº¿è¿½è¸ª
        function traceRay(origin, dir, depth = 0) {
            if (depth > 2) return [10, 10, 15];

            let closestT = Infinity;
            let closestColor = null;

            // åœ°æ¿
            const floorHit = rayPlaneIntersect(origin, dir, -2);
            if (floorHit && Math.abs(floorHit.x) < 8 && Math.abs(floorHit.z) < 8) {
                const t = floorHit.sub(origin).length();
                if (t < closestT) {
                    closestT = t;
                    const normal = new Vec3(0, 1, 0);
                    const viewDir = origin.sub(floorHit).normalize();
                    let color = computeLighting(floorHit, normal, viewDir);

                    // åœ°æ¿åå°„
                    if (params.floorReflection > 0 && depth < 1) {
                        const reflectDir = dir.reflect(normal);
                        const reflectColor = traceRay(floorHit, reflectDir, depth + 1);
                        for (let i = 0; i < 3; i++) {
                            color[i] = color[i] * (1 - params.floorReflection) + 
                                      reflectColor[i] * params.floorReflection;
                        }
                    }

                    // åœ°æ¿æ£‹ç›˜æ ¼
                    const checker = (Math.floor(floorHit.x) + Math.floor(floorHit.z)) % 2;
                    const checkerFactor = checker === 0 ? 0.4 : 0.3;
                    for (let i = 0; i < 3; i++) {
                        color[i] *= checkerFactor;
                    }

                    closestColor = color;
                }
            }

            // ç¯æ³¡
            const lampHit = raySphereIntersect(origin, dir, lightPos, 0.4);
            if (lampHit && lampHit.t < closestT) {
                closestT = lampHit.t;
                closestColor = params.lightColor.map(c => c * params.lightIntensity * 0.8);
            }

            // å¢™å£
            const walls = [
                { plane: 'x', value: -8, color: [15, 15, 20] },
                { plane: 'x', value: 8, color: [15, 15, 20] },
                { plane: 'z', value: -8, color: [20, 15, 15] },
                { plane: 'z', value: 8, color: [15, 20, 15] },
                { plane: 'y', value: 8, color: [15, 15, 25] }
            ];

            for (const wall of walls) {
                let hit = null;
                let normal = null;

                if (wall.plane === 'x') {
                    if (Math.abs(dir.x) > 0.001) {
                        const t = (wall.value - origin.x) / dir.x;
                        if (t > 0.001) {
                            const point = origin.add(dir.mul(t));
                            if (Math.abs(point.y) < 10 && Math.abs(point.z) < 8) {
                                hit = point;
                                normal = new Vec3(wall.value > 0 ? -1 : 1, 0, 0);
                            }
                        }
                    }
                } else if (wall.plane === 'y') {
                    if (Math.abs(dir.y) > 0.001) {
                        const t = (wall.value - origin.y) / dir.y;
                        if (t > 0.001) {
                            const point = origin.add(dir.mul(t));
                            if (Math.abs(point.x) < 8 && Math.abs(point.z) < 8) {
                                hit = point;
                                normal = new Vec3(0, -1, 0);
                            }
                        }
                    }
                } else if (wall.plane === 'z') {
                    if (Math.abs(dir.z) > 0.001) {
                        const t = (wall.value - origin.z) / dir.z;
                        if (t > 0.001) {
                            const point = origin.add(dir.mul(t));
                            if (Math.abs(point.x) < 8 && Math.abs(point.y) < 10) {
                                hit = point;
                                normal = new Vec3(0, 0, wall.value > 0 ? -1 : 1);
                            }
                        }
                    }
                }

                if (hit) {
                    const t = hit.sub(origin).length();
                    if (t < closestT) {
                        closestT = t;
                        const viewDir = origin.sub(hit).normalize();
                        let color = computeLighting(hit, normal, viewDir);
                        for (let i = 0; i < 3; i++) {
                            color[i] = Math.max(color[i], wall.color[i] * params.ambientLight);
                        }
                        closestColor = color;
                    }
                }
            }

            // ä½“ç§¯å…‰ï¼ˆå…‰é”¥é›¾æ•ˆï¼‰
            if (closestT < Infinity && params.volumetricDensity > 0) {
                const steps = 20;
                let volumetric = 0;
                for (let i = 0; i < steps; i++) {
                    const t = (closestT * i) / steps;
                    const samplePoint = origin.add(dir.mul(t));
                    if (isInLightCone(samplePoint)) {
                        const dist = samplePoint.sub(lightPos).length();
                        volumetric += params.volumetricDensity / (1 + dist * dist * 0.05);
                    }
                }
                volumetric /= steps;
                for (let i = 0; i < 3; i++) {
                    closestColor[i] += params.lightColor[i] * volumetric * params.lightIntensity * 15;
                }
            }

            return closestColor || [10, 10, 15];
        }

        // æ¸²æŸ“
        function render() {
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const cameraPos = getCameraPosition();
            const lookAt = new Vec3(0, 0, 0);
            const forward = lookAt.sub(cameraPos).normalize();
            const right = new Vec3(forward.z, 0, -forward.x).normalize();
            const up = right.sub(new Vec3(forward.x, 0, forward.z)).mul(forward.y).add(new Vec3(0, 1, 0)).normalize();

            const fov = Math.PI / 3;
            const aspectRatio = width / height;
            const scale = Math.tan(fov / 2);

            // è‡ªé€‚åº”åƒç´ å¤§å°
            const pixelSize = Math.max(1, Math.floor(Math.min(width, height) / 300));

            for (let y = 0; y < height; y += pixelSize) {
                for (let x = 0; x < width; x += pixelSize) {
                    const ndcX = (2 * (x + 0.5) / width - 1) * aspectRatio * scale;
                    const ndcY = (1 - 2 * (y + 0.5) / height) * scale;

                    const dir = forward.add(right.mul(ndcX)).add(up.mul(ndcY)).normalize();
                    const color = traceRay(cameraPos, dir);

                    // å¡«å……åƒç´ å—
                    for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                            const index = ((y + dy) * width + (x + dx)) * 4;
                            data[index] = Math.min(255, color[0]);
                            data[index + 1] = Math.min(255, color[1]);
                            data[index + 2] = Math.min(255, color[2]);
                            data[index + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // FPSè®¡æ•°
        let frameCount = 0;
        let lastTime = Date.now();

        function animate() {
            render();

            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
